{% extends "base.html" %}
{% block body %}
<link rel="stylesheet" href="{{ url_for('static', filename='main.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='phoebe.css') }}">
<style>
    /* Clean Crossword Styling */
    .cw-cell {
        width: 30px !important;
        height: 30px !important;
        text-align: center;
        font-weight: bold;
        text-transform: uppercase;
        border: 1px solid #555;
        border-radius: 0 !important; /* Force squares */
        padding: 0;
        font-size: 16px;
    }

    /* Completed/Correct Word Styling */
    .cw-cell.correct-word {
        background-color: #d4edda !important; /* Green */
        color: #155724 !important;
        pointer-events: none; /* Lock correct words */
    }
    
    /* Focused Cell */
    .cw-cell:focus {
        background-color: #fff9c4; /* Light yellow focus */
        outline: 2px solid #ffc107;
        z-index: 10;
    }

    /* Empty Cells (Invisible) */
    .empty-cell {
        width: 30px;
        height: 30px;
        visibility: hidden; /* Makes it blank white space */
        pointer-events: none;
    }
</style>

<div class="container-fluid mt-3">
    <div class="row">
        <div class="col-md-9 d-flex justify-content-center">
            <div class="cw-board" style="display: grid; grid-template-columns: repeat(25, 30px); gap: 0;">
                {% for r in range(30) %}
                    {% for c in range(25) %}
                        {% if (r, c) in layout %}
                            <input type="text" maxlength="1" 
                                   class="cw-cell" 
                                   id="cell-{{r}}-{{c}}"
                                   value="{{ current_state.get(r|string + '_' + c|string, '') }}"
                                   autocomplete="off"
                                   onkeydown="handleKey(event, {{r}}, {{c}})"
                                   oninput="handleInput(this, {{r}}, {{c}})">
                        {% else %}
                            <div class="empty-cell"></div>
                        {% endif %}
                    {% endfor %}
                {% endfor %}
            </div>
        </div>

        <div class="col-md-3">
            <div class="cw-sidebar p-3 border rounded bg-white shadow-sm">
                <h5 class="mb-3">Crossword</h5>
                <p class="small text-muted">Partner: <strong>{{ partner_name }}</strong></p>
                <div class="alert alert-info py-2 small">
                    Your Role: <strong>{% if my_role == 'p1' %}ACROSS (Horizontal){% else %}DOWN (Vertical){% endif %}</strong>
                    <br>
                    <span style="font-size: 0.85em">Type to move forward. Backspace to move back.</span>
                </div>

                <hr>
                <div class="chat-box" id="gameChat" style="height: 300px; overflow-y: auto; background: #f8f9fa; border: 1px solid #dee2e6;">
                    {% for msg in chat_history %}
                        <div class="msg"><b>{{ msg.username }}:</b> {{ msg.content }}</div>
                    {% endfor %}
                </div>
                <div class="input-group mt-2">
                    <input type="text" id="chatInput" class="form-control form-control-sm" placeholder="Type..." onkeypress="if(event.key==='Enter') sendChat()">
                    <button class="btn btn-sm btn-primary" onclick="sendChat()">Send</button>
                </div>
                
                <form action="{{ url_for('game_complete', game_type='crossword') }}" method="POST">
                    <input type="hidden" name="session_id" value="{{ session_id }}">
                    <button class="btn btn-success w-100 mt-3" id="btnComplete" style="display:none;">Finish Game</button>
                </form>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
<script>
    const socket = io();
    const sessionId = {{ session_id }};
    const myRole = "{{ my_role }}"; // 'p1' (Across) or 'p2' (Down)
    
    socket.emit('join_game', {session_id: sessionId});

    // --- NAVIGATION LOGIC ---

    function handleKey(e, r, c) {
        // Backspace Logic (Reverse Direction)
        if (e.key === "Backspace") {
            const el = document.getElementById(`cell-${r}-${c}`);
            
            // If current cell is empty, move back immediately
            // If it has a letter, we delete it (default behavior) THEN move back? 
            // Standard behavior: if empty, move back and delete prev. If full, just delete.
            // Let's stick to simple: If empty, move back.
            if (el.value === "") {
                e.preventDefault(); // Stop default backspace
                moveFocus(r, c, -1); // Move backward
            }
        } 
        // Arrow Keys (Allow free movement regardless of role)
        else if (e.key === "ArrowRight") focusCell(r, c+1);
        else if (e.key === "ArrowLeft") focusCell(r, c-1);
        else if (e.key === "ArrowDown") focusCell(r+1, c);
        else if (e.key === "ArrowUp") focusCell(r-1, c);
    }

    function handleInput(el, r, c) {
        let val = el.value.toUpperCase();
        el.value = val;
        
        // 1. Send move to server
        socket.emit('crossword_move', {
            session_id: sessionId, row: r, col: c, letter: val
        });

        // 2. Auto-advance if a letter was typed
        if (val.length === 1) {
            moveFocus(r, c, 1); // Move forward
        }
    }

    // Helper to move focus based on Role + Direction (1 = forward, -1 = backward)
    function moveFocus(r, c, direction) {
        let nextR = r;
        let nextC = c;

        if (myRole === 'p1') {
            // Player 1 = ACROSS (Change Column)
            nextC = c + direction;
        } else {
            // Player 2 = DOWN (Change Row)
            nextR = r + direction;
        }

        let nextCell = document.getElementById(`cell-${nextR}-${nextC}`);
        
        // Only focus if the cell actually exists (is part of a word)
        if (nextCell) {
            nextCell.focus();
            // Optional: for backspace, we might want to prevent deleting the prev letter immediately
            // unless we are in "overwrite" mode. 
        }
    }

    function focusCell(r, c) {
        let el = document.getElementById(`cell-${r}-${c}`);
        if (el) el.focus();
    }

    // --- SOCKET EVENTS ---

    socket.on('update_grid', (data) => {
        let cell = document.getElementById(`cell-${data.row}-${data.col}`);
        if(cell) {
            cell.value = data.letter;
            // Visual feedback that partner typed something?
            cell.style.backgroundColor = '#eef';
            setTimeout(() => cell.style.backgroundColor = '', 500);
        }
    });

    socket.on('word_complete', (data) => {
        data.cells.forEach(pos => {
            let cell = document.getElementById(`cell-${pos.r}-${pos.c}`);
            if(cell) {
                cell.classList.add('correct-word');
                cell.readOnly = true; 
            }
        });
        
        // Show finish button if enough words are found
        if (data.found >= data.total) { 
             document.getElementById('btnComplete').style.display = 'block';
        }
    });

    // --- CHAT ---

    function sendChat() {
        let input = document.getElementById('chatInput');
        if(input.value.trim()) {
            socket.emit('game_chat_message', {session_id: sessionId, msg: input.value});
            input.value = '';
        }
    }

    socket.on('game_chat_receive', (data) => {
        let box = document.getElementById('gameChat');
        box.innerHTML += `<div class="msg"><b>${data.user}:</b> ${data.msg}</div>`;
        box.scrollTop = box.scrollHeight;
    });
</script>
{% endblock %}